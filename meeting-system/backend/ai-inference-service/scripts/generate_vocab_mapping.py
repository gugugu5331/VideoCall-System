#!/usr/bin/env python3
"""
ç”Ÿæˆ Wav2Vec2 è¯æ±‡è¡¨æ˜ å°„æ–‡ä»¶

å°† HuggingFace çš„è¯æ±‡è¡¨è½¬æ¢ä¸º C++ å¯ä»¥ä½¿ç”¨çš„æ ¼å¼
"""

import json
from pathlib import Path
from transformers import Wav2Vec2Processor


def generate_asr_vocab():
    """ç”Ÿæˆ ASR æ¨¡å‹çš„è¯æ±‡è¡¨"""
    print("=" * 80)
    print("ğŸ¯ ç”Ÿæˆ ASR è¯æ±‡è¡¨æ˜ å°„")
    print("=" * 80)
    print()
    
    model_name = "facebook/wav2vec2-base-960h"
    
    print(f"ğŸ“¥ åŠ è½½å¤„ç†å™¨: {model_name}")
    processor = Wav2Vec2Processor.from_pretrained(model_name)
    
    # è·å–è¯æ±‡è¡¨
    vocab = processor.tokenizer.get_vocab()
    
    # åˆ›å»º ID åˆ°å­—ç¬¦çš„æ˜ å°„
    id2char = {v: k for k, v in vocab.items()}
    
    # ä¿å­˜ä¸º JSON
    output_path = Path("/work/models/asr_vocab.json")
    with open(output_path, 'w') as f:
        json.dump(id2char, f, indent=2)
    
    print(f"âœ… è¯æ±‡è¡¨å·²ä¿å­˜åˆ°: {output_path}")
    print(f"   è¯æ±‡è¡¨å¤§å°: {len(id2char)}")
    print()
    
    # æ˜¾ç¤ºéƒ¨åˆ†è¯æ±‡
    print("ğŸ“Š è¯æ±‡è¡¨ç¤ºä¾‹:")
    for i in range(min(10, len(id2char))):
        char = id2char.get(i, "")
        print(f"   {i}: '{char}'")
    print()
    
    # ç”Ÿæˆ C++ å¤´æ–‡ä»¶
    cpp_header = """// Auto-generated vocabulary mapping for Wav2Vec2 ASR
// Generated by generate_vocab_mapping.py

#ifndef ASR_VOCAB_H
#define ASR_VOCAB_H

#include <string>
#include <unordered_map>

namespace AIInference {

// Vocabulary size
const int VOCAB_SIZE = """ + str(len(id2char)) + """;

// ID to character mapping
const std::unordered_map<int, std::string> ID2CHAR = {
"""
    
    for idx, char in id2char.items():
        # è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
        char_escaped = char.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\t', '\\t')
        cpp_header += f'    {{{idx}, "{char_escaped}"}},\n'
    
    cpp_header += """};

} // namespace AIInference

#endif // ASR_VOCAB_H
"""
    
    cpp_header_path = Path("/work/models/asr_vocab.h")
    with open(cpp_header_path, 'w') as f:
        f.write(cpp_header)
    
    print(f"âœ… C++ å¤´æ–‡ä»¶å·²ä¿å­˜åˆ°: {cpp_header_path}")
    print()
    
    return True


def generate_emotion_labels():
    """ç”Ÿæˆæƒ…æ„Ÿæ£€æµ‹æ¨¡å‹çš„æ ‡ç­¾æ˜ å°„"""
    print("=" * 80)
    print("ğŸ¯ ç”Ÿæˆ Emotion Detection æ ‡ç­¾æ˜ å°„")
    print("=" * 80)
    print()
    
    model_name = "ehcalabres/wav2vec2-lg-xlsr-en-speech-emotion-recognition"
    
    print(f"ğŸ“¥ åŠ è½½æ¨¡å‹é…ç½®: {model_name}")
    from transformers import Wav2Vec2ForSequenceClassification
    
    model = Wav2Vec2ForSequenceClassification.from_pretrained(model_name)
    
    # è·å–æ ‡ç­¾æ˜ å°„
    id2label = model.config.id2label
    
    # ä¿å­˜ä¸º JSON
    output_path = Path("/work/models/emotion_labels.json")
    with open(output_path, 'w') as f:
        json.dump(id2label, f, indent=2)
    
    print(f"âœ… æ ‡ç­¾æ˜ å°„å·²ä¿å­˜åˆ°: {output_path}")
    print(f"   æ ‡ç­¾æ•°é‡: {len(id2label)}")
    print()
    
    # æ˜¾ç¤ºæ ‡ç­¾
    print("ğŸ“Š æƒ…æ„Ÿæ ‡ç­¾:")
    for idx, label in id2label.items():
        print(f"   {idx}: {label}")
    print()
    
    # ç”Ÿæˆ C++ å¤´æ–‡ä»¶
    cpp_header = """// Auto-generated emotion labels for Wav2Vec2 Emotion Detection
// Generated by generate_vocab_mapping.py

#ifndef EMOTION_LABELS_H
#define EMOTION_LABELS_H

#include <string>
#include <vector>

namespace AIInference {

// Emotion labels
const std::vector<std::string> EMOTION_LABELS = {
"""

    for idx in sorted([int(k) for k in id2label.keys()]):
        label = id2label[idx]
        cpp_header += f'    "{label}",  // {idx}\n'
    
    cpp_header += """};

} // namespace AIInference

#endif // EMOTION_LABELS_H
"""
    
    cpp_header_path = Path("/work/models/emotion_labels.h")
    with open(cpp_header_path, 'w') as f:
        f.write(cpp_header)
    
    print(f"âœ… C++ å¤´æ–‡ä»¶å·²ä¿å­˜åˆ°: {cpp_header_path}")
    print()
    
    return True


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="ç”Ÿæˆè¯æ±‡è¡¨å’Œæ ‡ç­¾æ˜ å°„")
    parser.add_argument(
        "--type",
        type=str,
        choices=["asr", "emotion", "all"],
        default="all",
        help="ç”Ÿæˆå“ªç§æ˜ å°„"
    )
    
    args = parser.parse_args()
    
    success = True
    
    if args.type in ["asr", "all"]:
        if not generate_asr_vocab():
            success = False
    
    if args.type in ["emotion", "all"]:
        if not generate_emotion_labels():
            success = False
    
    print("=" * 80)
    print("ğŸ‰ æ˜ å°„æ–‡ä»¶ç”Ÿæˆå®Œæˆï¼")
    print("=" * 80)
    
    import sys
    sys.exit(0 if success else 1)

