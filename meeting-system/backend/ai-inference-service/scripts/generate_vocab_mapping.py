#!/usr/bin/env python3
"""
生成 Wav2Vec2 词汇表映射文件

将 HuggingFace 的词汇表转换为 C++ 可以使用的格式
"""

import json
from pathlib import Path
from transformers import Wav2Vec2Processor


def generate_asr_vocab():
    """生成 ASR 模型的词汇表"""
    print("=" * 80)
    print("🎯 生成 ASR 词汇表映射")
    print("=" * 80)
    print()
    
    model_name = "facebook/wav2vec2-base-960h"
    
    print(f"📥 加载处理器: {model_name}")
    processor = Wav2Vec2Processor.from_pretrained(model_name)
    
    # 获取词汇表
    vocab = processor.tokenizer.get_vocab()
    
    # 创建 ID 到字符的映射
    id2char = {v: k for k, v in vocab.items()}
    
    # 保存为 JSON
    output_path = Path("/work/models/asr_vocab.json")
    with open(output_path, 'w') as f:
        json.dump(id2char, f, indent=2)
    
    print(f"✅ 词汇表已保存到: {output_path}")
    print(f"   词汇表大小: {len(id2char)}")
    print()
    
    # 显示部分词汇
    print("📊 词汇表示例:")
    for i in range(min(10, len(id2char))):
        char = id2char.get(i, "")
        print(f"   {i}: '{char}'")
    print()
    
    # 生成 C++ 头文件
    cpp_header = """// Auto-generated vocabulary mapping for Wav2Vec2 ASR
// Generated by generate_vocab_mapping.py

#ifndef ASR_VOCAB_H
#define ASR_VOCAB_H

#include <string>
#include <unordered_map>

namespace AIInference {

// Vocabulary size
const int VOCAB_SIZE = """ + str(len(id2char)) + """;

// ID to character mapping
const std::unordered_map<int, std::string> ID2CHAR = {
"""
    
    for idx, char in id2char.items():
        # 转义特殊字符
        char_escaped = char.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\t', '\\t')
        cpp_header += f'    {{{idx}, "{char_escaped}"}},\n'
    
    cpp_header += """};

} // namespace AIInference

#endif // ASR_VOCAB_H
"""
    
    cpp_header_path = Path("/work/models/asr_vocab.h")
    with open(cpp_header_path, 'w') as f:
        f.write(cpp_header)
    
    print(f"✅ C++ 头文件已保存到: {cpp_header_path}")
    print()
    
    return True


def generate_emotion_labels():
    """生成情感检测模型的标签映射"""
    print("=" * 80)
    print("🎯 生成 Emotion Detection 标签映射")
    print("=" * 80)
    print()
    
    model_name = "ehcalabres/wav2vec2-lg-xlsr-en-speech-emotion-recognition"
    
    print(f"📥 加载模型配置: {model_name}")
    from transformers import Wav2Vec2ForSequenceClassification
    
    model = Wav2Vec2ForSequenceClassification.from_pretrained(model_name)
    
    # 获取标签映射
    id2label = model.config.id2label
    
    # 保存为 JSON
    output_path = Path("/work/models/emotion_labels.json")
    with open(output_path, 'w') as f:
        json.dump(id2label, f, indent=2)
    
    print(f"✅ 标签映射已保存到: {output_path}")
    print(f"   标签数量: {len(id2label)}")
    print()
    
    # 显示标签
    print("📊 情感标签:")
    for idx, label in id2label.items():
        print(f"   {idx}: {label}")
    print()
    
    # 生成 C++ 头文件
    cpp_header = """// Auto-generated emotion labels for Wav2Vec2 Emotion Detection
// Generated by generate_vocab_mapping.py

#ifndef EMOTION_LABELS_H
#define EMOTION_LABELS_H

#include <string>
#include <vector>

namespace AIInference {

// Emotion labels
const std::vector<std::string> EMOTION_LABELS = {
"""

    for idx in sorted([int(k) for k in id2label.keys()]):
        label = id2label[idx]
        cpp_header += f'    "{label}",  // {idx}\n'
    
    cpp_header += """};

} // namespace AIInference

#endif // EMOTION_LABELS_H
"""
    
    cpp_header_path = Path("/work/models/emotion_labels.h")
    with open(cpp_header_path, 'w') as f:
        f.write(cpp_header)
    
    print(f"✅ C++ 头文件已保存到: {cpp_header_path}")
    print()
    
    return True


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="生成词汇表和标签映射")
    parser.add_argument(
        "--type",
        type=str,
        choices=["asr", "emotion", "all"],
        default="all",
        help="生成哪种映射"
    )
    
    args = parser.parse_args()
    
    success = True
    
    if args.type in ["asr", "all"]:
        if not generate_asr_vocab():
            success = False
    
    if args.type in ["emotion", "all"]:
        if not generate_emotion_labels():
            success = False
    
    print("=" * 80)
    print("🎉 映射文件生成完成！")
    print("=" * 80)
    
    import sys
    sys.exit(0 if success else 1)

