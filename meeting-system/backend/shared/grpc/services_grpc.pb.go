// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.6.1
// source: services.proto

package grpc

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserService_GetUser_FullMethodName          = "/grpc.UserService/GetUser"
	UserService_ValidateToken_FullMethodName    = "/grpc.UserService/ValidateToken"
	UserService_GetUsersByIds_FullMethodName    = "/grpc.UserService/GetUsersByIds"
	UserService_UpdateUserStatus_FullMethodName = "/grpc.UserService/UpdateUserStatus"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 用户服务接口
type UserServiceClient interface {
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	GetUsersByIds(ctx context.Context, in *GetUsersByIdsRequest, opts ...grpc.CallOption) (*GetUsersByIdsResponse, error)
	UpdateUserStatus(ctx context.Context, in *UpdateUserStatusRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, UserService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUsersByIds(ctx context.Context, in *GetUsersByIdsRequest, opts ...grpc.CallOption) (*GetUsersByIdsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsersByIdsResponse)
	err := c.cc.Invoke(ctx, UserService_GetUsersByIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUserStatus(ctx context.Context, in *UpdateUserStatusRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, UserService_UpdateUserStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
//
// 用户服务接口
type UserServiceServer interface {
	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	GetUsersByIds(context.Context, *GetUsersByIdsRequest) (*GetUsersByIdsResponse, error)
	UpdateUserStatus(context.Context, *UpdateUserStatusRequest) (*empty.Empty, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedUserServiceServer) GetUsersByIds(context.Context, *GetUsersByIdsRequest) (*GetUsersByIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsersByIds not implemented")
}
func (UnimplementedUserServiceServer) UpdateUserStatus(context.Context, *UpdateUserStatusRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserStatus not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUsersByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsersByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUsersByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUsersByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUsersByIds(ctx, req.(*GetUsersByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUserStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUserStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUserStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUserStatus(ctx, req.(*UpdateUserStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _UserService_ValidateToken_Handler,
		},
		{
			MethodName: "GetUsersByIds",
			Handler:    _UserService_GetUsersByIds_Handler,
		},
		{
			MethodName: "UpdateUserStatus",
			Handler:    _UserService_UpdateUserStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

const (
	MeetingService_GetMeeting_FullMethodName          = "/grpc.MeetingService/GetMeeting"
	MeetingService_ValidateUserAccess_FullMethodName  = "/grpc.MeetingService/ValidateUserAccess"
	MeetingService_UpdateMeetingStatus_FullMethodName = "/grpc.MeetingService/UpdateMeetingStatus"
	MeetingService_GetActiveMeetings_FullMethodName   = "/grpc.MeetingService/GetActiveMeetings"
)

// MeetingServiceClient is the client API for MeetingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 会议服务接口
type MeetingServiceClient interface {
	GetMeeting(ctx context.Context, in *GetMeetingRequest, opts ...grpc.CallOption) (*GetMeetingResponse, error)
	ValidateUserAccess(ctx context.Context, in *ValidateUserAccessRequest, opts ...grpc.CallOption) (*ValidateUserAccessResponse, error)
	UpdateMeetingStatus(ctx context.Context, in *UpdateMeetingStatusRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	GetActiveMeetings(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetActiveMeetingsResponse, error)
}

type meetingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMeetingServiceClient(cc grpc.ClientConnInterface) MeetingServiceClient {
	return &meetingServiceClient{cc}
}

func (c *meetingServiceClient) GetMeeting(ctx context.Context, in *GetMeetingRequest, opts ...grpc.CallOption) (*GetMeetingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMeetingResponse)
	err := c.cc.Invoke(ctx, MeetingService_GetMeeting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meetingServiceClient) ValidateUserAccess(ctx context.Context, in *ValidateUserAccessRequest, opts ...grpc.CallOption) (*ValidateUserAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateUserAccessResponse)
	err := c.cc.Invoke(ctx, MeetingService_ValidateUserAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meetingServiceClient) UpdateMeetingStatus(ctx context.Context, in *UpdateMeetingStatusRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MeetingService_UpdateMeetingStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meetingServiceClient) GetActiveMeetings(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetActiveMeetingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveMeetingsResponse)
	err := c.cc.Invoke(ctx, MeetingService_GetActiveMeetings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeetingServiceServer is the server API for MeetingService service.
// All implementations must embed UnimplementedMeetingServiceServer
// for forward compatibility.
//
// 会议服务接口
type MeetingServiceServer interface {
	GetMeeting(context.Context, *GetMeetingRequest) (*GetMeetingResponse, error)
	ValidateUserAccess(context.Context, *ValidateUserAccessRequest) (*ValidateUserAccessResponse, error)
	UpdateMeetingStatus(context.Context, *UpdateMeetingStatusRequest) (*empty.Empty, error)
	GetActiveMeetings(context.Context, *empty.Empty) (*GetActiveMeetingsResponse, error)
	mustEmbedUnimplementedMeetingServiceServer()
}

// UnimplementedMeetingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMeetingServiceServer struct{}

func (UnimplementedMeetingServiceServer) GetMeeting(context.Context, *GetMeetingRequest) (*GetMeetingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMeeting not implemented")
}
func (UnimplementedMeetingServiceServer) ValidateUserAccess(context.Context, *ValidateUserAccessRequest) (*ValidateUserAccessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateUserAccess not implemented")
}
func (UnimplementedMeetingServiceServer) UpdateMeetingStatus(context.Context, *UpdateMeetingStatusRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMeetingStatus not implemented")
}
func (UnimplementedMeetingServiceServer) GetActiveMeetings(context.Context, *empty.Empty) (*GetActiveMeetingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveMeetings not implemented")
}
func (UnimplementedMeetingServiceServer) mustEmbedUnimplementedMeetingServiceServer() {}
func (UnimplementedMeetingServiceServer) testEmbeddedByValue()                        {}

// UnsafeMeetingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MeetingServiceServer will
// result in compilation errors.
type UnsafeMeetingServiceServer interface {
	mustEmbedUnimplementedMeetingServiceServer()
}

func RegisterMeetingServiceServer(s grpc.ServiceRegistrar, srv MeetingServiceServer) {
	// If the following call pancis, it indicates UnimplementedMeetingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MeetingService_ServiceDesc, srv)
}

func _MeetingService_GetMeeting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMeetingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeetingServiceServer).GetMeeting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeetingService_GetMeeting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeetingServiceServer).GetMeeting(ctx, req.(*GetMeetingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeetingService_ValidateUserAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateUserAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeetingServiceServer).ValidateUserAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeetingService_ValidateUserAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeetingServiceServer).ValidateUserAccess(ctx, req.(*ValidateUserAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeetingService_UpdateMeetingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMeetingStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeetingServiceServer).UpdateMeetingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeetingService_UpdateMeetingStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeetingServiceServer).UpdateMeetingStatus(ctx, req.(*UpdateMeetingStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeetingService_GetActiveMeetings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeetingServiceServer).GetActiveMeetings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeetingService_GetActiveMeetings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeetingServiceServer).GetActiveMeetings(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// MeetingService_ServiceDesc is the grpc.ServiceDesc for MeetingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MeetingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.MeetingService",
	HandlerType: (*MeetingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMeeting",
			Handler:    _MeetingService_GetMeeting_Handler,
		},
		{
			MethodName: "ValidateUserAccess",
			Handler:    _MeetingService_ValidateUserAccess_Handler,
		},
		{
			MethodName: "UpdateMeetingStatus",
			Handler:    _MeetingService_UpdateMeetingStatus_Handler,
		},
		{
			MethodName: "GetActiveMeetings",
			Handler:    _MeetingService_GetActiveMeetings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

const (
	MediaService_NotifyRecordingStarted_FullMethodName = "/grpc.MediaService/NotifyRecordingStarted"
	MediaService_NotifyRecordingStopped_FullMethodName = "/grpc.MediaService/NotifyRecordingStopped"
	MediaService_NotifyMediaProcessing_FullMethodName  = "/grpc.MediaService/NotifyMediaProcessing"
	MediaService_GetMediaStats_FullMethodName          = "/grpc.MediaService/GetMediaStats"
)

// MediaServiceClient is the client API for MediaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 媒体服务接口
type MediaServiceClient interface {
	NotifyRecordingStarted(ctx context.Context, in *NotifyRecordingStartedRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	NotifyRecordingStopped(ctx context.Context, in *NotifyRecordingStoppedRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	NotifyMediaProcessing(ctx context.Context, in *NotifyMediaProcessingRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	GetMediaStats(ctx context.Context, in *GetMediaStatsRequest, opts ...grpc.CallOption) (*GetMediaStatsResponse, error)
}

type mediaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMediaServiceClient(cc grpc.ClientConnInterface) MediaServiceClient {
	return &mediaServiceClient{cc}
}

func (c *mediaServiceClient) NotifyRecordingStarted(ctx context.Context, in *NotifyRecordingStartedRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MediaService_NotifyRecordingStarted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) NotifyRecordingStopped(ctx context.Context, in *NotifyRecordingStoppedRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MediaService_NotifyRecordingStopped_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) NotifyMediaProcessing(ctx context.Context, in *NotifyMediaProcessingRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MediaService_NotifyMediaProcessing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) GetMediaStats(ctx context.Context, in *GetMediaStatsRequest, opts ...grpc.CallOption) (*GetMediaStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMediaStatsResponse)
	err := c.cc.Invoke(ctx, MediaService_GetMediaStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MediaServiceServer is the server API for MediaService service.
// All implementations must embed UnimplementedMediaServiceServer
// for forward compatibility.
//
// 媒体服务接口
type MediaServiceServer interface {
	NotifyRecordingStarted(context.Context, *NotifyRecordingStartedRequest) (*empty.Empty, error)
	NotifyRecordingStopped(context.Context, *NotifyRecordingStoppedRequest) (*empty.Empty, error)
	NotifyMediaProcessing(context.Context, *NotifyMediaProcessingRequest) (*empty.Empty, error)
	GetMediaStats(context.Context, *GetMediaStatsRequest) (*GetMediaStatsResponse, error)
	mustEmbedUnimplementedMediaServiceServer()
}

// UnimplementedMediaServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMediaServiceServer struct{}

func (UnimplementedMediaServiceServer) NotifyRecordingStarted(context.Context, *NotifyRecordingStartedRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyRecordingStarted not implemented")
}
func (UnimplementedMediaServiceServer) NotifyRecordingStopped(context.Context, *NotifyRecordingStoppedRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyRecordingStopped not implemented")
}
func (UnimplementedMediaServiceServer) NotifyMediaProcessing(context.Context, *NotifyMediaProcessingRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyMediaProcessing not implemented")
}
func (UnimplementedMediaServiceServer) GetMediaStats(context.Context, *GetMediaStatsRequest) (*GetMediaStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMediaStats not implemented")
}
func (UnimplementedMediaServiceServer) mustEmbedUnimplementedMediaServiceServer() {}
func (UnimplementedMediaServiceServer) testEmbeddedByValue()                      {}

// UnsafeMediaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MediaServiceServer will
// result in compilation errors.
type UnsafeMediaServiceServer interface {
	mustEmbedUnimplementedMediaServiceServer()
}

func RegisterMediaServiceServer(s grpc.ServiceRegistrar, srv MediaServiceServer) {
	// If the following call pancis, it indicates UnimplementedMediaServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MediaService_ServiceDesc, srv)
}

func _MediaService_NotifyRecordingStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyRecordingStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).NotifyRecordingStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_NotifyRecordingStarted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).NotifyRecordingStarted(ctx, req.(*NotifyRecordingStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_NotifyRecordingStopped_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyRecordingStoppedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).NotifyRecordingStopped(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_NotifyRecordingStopped_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).NotifyRecordingStopped(ctx, req.(*NotifyRecordingStoppedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_NotifyMediaProcessing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyMediaProcessingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).NotifyMediaProcessing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_NotifyMediaProcessing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).NotifyMediaProcessing(ctx, req.(*NotifyMediaProcessingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_GetMediaStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMediaStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).GetMediaStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_GetMediaStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).GetMediaStats(ctx, req.(*GetMediaStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MediaService_ServiceDesc is the grpc.ServiceDesc for MediaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MediaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.MediaService",
	HandlerType: (*MediaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NotifyRecordingStarted",
			Handler:    _MediaService_NotifyRecordingStarted_Handler,
		},
		{
			MethodName: "NotifyRecordingStopped",
			Handler:    _MediaService_NotifyRecordingStopped_Handler,
		},
		{
			MethodName: "NotifyMediaProcessing",
			Handler:    _MediaService_NotifyMediaProcessing_Handler,
		},
		{
			MethodName: "GetMediaStats",
			Handler:    _MediaService_GetMediaStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

const (
	SignalingService_NotifyUserJoined_FullMethodName = "/grpc.SignalingService/NotifyUserJoined"
	SignalingService_NotifyUserLeft_FullMethodName   = "/grpc.SignalingService/NotifyUserLeft"
	SignalingService_BroadcastMessage_FullMethodName = "/grpc.SignalingService/BroadcastMessage"
	SignalingService_GetRoomUsers_FullMethodName     = "/grpc.SignalingService/GetRoomUsers"
)

// SignalingServiceClient is the client API for SignalingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 信令服务接口
type SignalingServiceClient interface {
	NotifyUserJoined(ctx context.Context, in *NotifyUserJoinedRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	NotifyUserLeft(ctx context.Context, in *NotifyUserLeftRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	BroadcastMessage(ctx context.Context, in *BroadcastMessageRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	GetRoomUsers(ctx context.Context, in *GetRoomUsersRequest, opts ...grpc.CallOption) (*GetRoomUsersResponse, error)
}

type signalingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSignalingServiceClient(cc grpc.ClientConnInterface) SignalingServiceClient {
	return &signalingServiceClient{cc}
}

func (c *signalingServiceClient) NotifyUserJoined(ctx context.Context, in *NotifyUserJoinedRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, SignalingService_NotifyUserJoined_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signalingServiceClient) NotifyUserLeft(ctx context.Context, in *NotifyUserLeftRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, SignalingService_NotifyUserLeft_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signalingServiceClient) BroadcastMessage(ctx context.Context, in *BroadcastMessageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, SignalingService_BroadcastMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signalingServiceClient) GetRoomUsers(ctx context.Context, in *GetRoomUsersRequest, opts ...grpc.CallOption) (*GetRoomUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoomUsersResponse)
	err := c.cc.Invoke(ctx, SignalingService_GetRoomUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SignalingServiceServer is the server API for SignalingService service.
// All implementations must embed UnimplementedSignalingServiceServer
// for forward compatibility.
//
// 信令服务接口
type SignalingServiceServer interface {
	NotifyUserJoined(context.Context, *NotifyUserJoinedRequest) (*empty.Empty, error)
	NotifyUserLeft(context.Context, *NotifyUserLeftRequest) (*empty.Empty, error)
	BroadcastMessage(context.Context, *BroadcastMessageRequest) (*empty.Empty, error)
	GetRoomUsers(context.Context, *GetRoomUsersRequest) (*GetRoomUsersResponse, error)
	mustEmbedUnimplementedSignalingServiceServer()
}

// UnimplementedSignalingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSignalingServiceServer struct{}

func (UnimplementedSignalingServiceServer) NotifyUserJoined(context.Context, *NotifyUserJoinedRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyUserJoined not implemented")
}
func (UnimplementedSignalingServiceServer) NotifyUserLeft(context.Context, *NotifyUserLeftRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyUserLeft not implemented")
}
func (UnimplementedSignalingServiceServer) BroadcastMessage(context.Context, *BroadcastMessageRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastMessage not implemented")
}
func (UnimplementedSignalingServiceServer) GetRoomUsers(context.Context, *GetRoomUsersRequest) (*GetRoomUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoomUsers not implemented")
}
func (UnimplementedSignalingServiceServer) mustEmbedUnimplementedSignalingServiceServer() {}
func (UnimplementedSignalingServiceServer) testEmbeddedByValue()                          {}

// UnsafeSignalingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SignalingServiceServer will
// result in compilation errors.
type UnsafeSignalingServiceServer interface {
	mustEmbedUnimplementedSignalingServiceServer()
}

func RegisterSignalingServiceServer(s grpc.ServiceRegistrar, srv SignalingServiceServer) {
	// If the following call pancis, it indicates UnimplementedSignalingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SignalingService_ServiceDesc, srv)
}

func _SignalingService_NotifyUserJoined_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyUserJoinedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignalingServiceServer).NotifyUserJoined(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SignalingService_NotifyUserJoined_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignalingServiceServer).NotifyUserJoined(ctx, req.(*NotifyUserJoinedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SignalingService_NotifyUserLeft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyUserLeftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignalingServiceServer).NotifyUserLeft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SignalingService_NotifyUserLeft_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignalingServiceServer).NotifyUserLeft(ctx, req.(*NotifyUserLeftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SignalingService_BroadcastMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignalingServiceServer).BroadcastMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SignalingService_BroadcastMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignalingServiceServer).BroadcastMessage(ctx, req.(*BroadcastMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SignalingService_GetRoomUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoomUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignalingServiceServer).GetRoomUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SignalingService_GetRoomUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignalingServiceServer).GetRoomUsers(ctx, req.(*GetRoomUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SignalingService_ServiceDesc is the grpc.ServiceDesc for SignalingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SignalingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.SignalingService",
	HandlerType: (*SignalingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NotifyUserJoined",
			Handler:    _SignalingService_NotifyUserJoined_Handler,
		},
		{
			MethodName: "NotifyUserLeft",
			Handler:    _SignalingService_NotifyUserLeft_Handler,
		},
		{
			MethodName: "BroadcastMessage",
			Handler:    _SignalingService_BroadcastMessage_Handler,
		},
		{
			MethodName: "GetRoomUsers",
			Handler:    _SignalingService_GetRoomUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

const (
	AIService_ProcessAudioData_FullMethodName      = "/grpc.AIService/ProcessAudioData"
	AIService_ProcessVideoFrame_FullMethodName     = "/grpc.AIService/ProcessVideoFrame"
	AIService_StreamAudioProcessing_FullMethodName = "/grpc.AIService/StreamAudioProcessing"
	AIService_StreamVideoProcessing_FullMethodName = "/grpc.AIService/StreamVideoProcessing"
	AIService_GetAIAnalysis_FullMethodName         = "/grpc.AIService/GetAIAnalysis"
	AIService_NotifyAIResult_FullMethodName        = "/grpc.AIService/NotifyAIResult"
)

// AIServiceClient is the client API for AIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// AI服务接口
type AIServiceClient interface {
	// 一元 RPC：批量处理音频数据（兼容现有实现）
	ProcessAudioData(ctx context.Context, in *ProcessAudioDataRequest, opts ...grpc.CallOption) (*ProcessAudioDataResponse, error)
	// 一元 RPC：批量处理视频帧（兼容现有实现）
	ProcessVideoFrame(ctx context.Context, in *ProcessVideoFrameRequest, opts ...grpc.CallOption) (*ProcessVideoFrameResponse, error)
	// 双向流式 RPC：实时音频处理（方案二）
	StreamAudioProcessing(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AudioChunk, AIStreamResult], error)
	// 双向流式 RPC：实时视频处理（方案二）
	StreamVideoProcessing(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[VideoChunk, AIStreamResult], error)
	// 获取 AI 分析结果
	GetAIAnalysis(ctx context.Context, in *GetAIAnalysisRequest, opts ...grpc.CallOption) (*GetAIAnalysisResponse, error)
	// 通知 AI 结果
	NotifyAIResult(ctx context.Context, in *NotifyAIResultRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type aIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAIServiceClient(cc grpc.ClientConnInterface) AIServiceClient {
	return &aIServiceClient{cc}
}

func (c *aIServiceClient) ProcessAudioData(ctx context.Context, in *ProcessAudioDataRequest, opts ...grpc.CallOption) (*ProcessAudioDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessAudioDataResponse)
	err := c.cc.Invoke(ctx, AIService_ProcessAudioData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aIServiceClient) ProcessVideoFrame(ctx context.Context, in *ProcessVideoFrameRequest, opts ...grpc.CallOption) (*ProcessVideoFrameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessVideoFrameResponse)
	err := c.cc.Invoke(ctx, AIService_ProcessVideoFrame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aIServiceClient) StreamAudioProcessing(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AudioChunk, AIStreamResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AIService_ServiceDesc.Streams[0], AIService_StreamAudioProcessing_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AudioChunk, AIStreamResult]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AIService_StreamAudioProcessingClient = grpc.BidiStreamingClient[AudioChunk, AIStreamResult]

func (c *aIServiceClient) StreamVideoProcessing(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[VideoChunk, AIStreamResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AIService_ServiceDesc.Streams[1], AIService_StreamVideoProcessing_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[VideoChunk, AIStreamResult]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AIService_StreamVideoProcessingClient = grpc.BidiStreamingClient[VideoChunk, AIStreamResult]

func (c *aIServiceClient) GetAIAnalysis(ctx context.Context, in *GetAIAnalysisRequest, opts ...grpc.CallOption) (*GetAIAnalysisResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAIAnalysisResponse)
	err := c.cc.Invoke(ctx, AIService_GetAIAnalysis_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aIServiceClient) NotifyAIResult(ctx context.Context, in *NotifyAIResultRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, AIService_NotifyAIResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AIServiceServer is the server API for AIService service.
// All implementations must embed UnimplementedAIServiceServer
// for forward compatibility.
//
// AI服务接口
type AIServiceServer interface {
	// 一元 RPC：批量处理音频数据（兼容现有实现）
	ProcessAudioData(context.Context, *ProcessAudioDataRequest) (*ProcessAudioDataResponse, error)
	// 一元 RPC：批量处理视频帧（兼容现有实现）
	ProcessVideoFrame(context.Context, *ProcessVideoFrameRequest) (*ProcessVideoFrameResponse, error)
	// 双向流式 RPC：实时音频处理（方案二）
	StreamAudioProcessing(grpc.BidiStreamingServer[AudioChunk, AIStreamResult]) error
	// 双向流式 RPC：实时视频处理（方案二）
	StreamVideoProcessing(grpc.BidiStreamingServer[VideoChunk, AIStreamResult]) error
	// 获取 AI 分析结果
	GetAIAnalysis(context.Context, *GetAIAnalysisRequest) (*GetAIAnalysisResponse, error)
	// 通知 AI 结果
	NotifyAIResult(context.Context, *NotifyAIResultRequest) (*empty.Empty, error)
	mustEmbedUnimplementedAIServiceServer()
}

// UnimplementedAIServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAIServiceServer struct{}

func (UnimplementedAIServiceServer) ProcessAudioData(context.Context, *ProcessAudioDataRequest) (*ProcessAudioDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessAudioData not implemented")
}
func (UnimplementedAIServiceServer) ProcessVideoFrame(context.Context, *ProcessVideoFrameRequest) (*ProcessVideoFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessVideoFrame not implemented")
}
func (UnimplementedAIServiceServer) StreamAudioProcessing(grpc.BidiStreamingServer[AudioChunk, AIStreamResult]) error {
	return status.Errorf(codes.Unimplemented, "method StreamAudioProcessing not implemented")
}
func (UnimplementedAIServiceServer) StreamVideoProcessing(grpc.BidiStreamingServer[VideoChunk, AIStreamResult]) error {
	return status.Errorf(codes.Unimplemented, "method StreamVideoProcessing not implemented")
}
func (UnimplementedAIServiceServer) GetAIAnalysis(context.Context, *GetAIAnalysisRequest) (*GetAIAnalysisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAIAnalysis not implemented")
}
func (UnimplementedAIServiceServer) NotifyAIResult(context.Context, *NotifyAIResultRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyAIResult not implemented")
}
func (UnimplementedAIServiceServer) mustEmbedUnimplementedAIServiceServer() {}
func (UnimplementedAIServiceServer) testEmbeddedByValue()                   {}

// UnsafeAIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AIServiceServer will
// result in compilation errors.
type UnsafeAIServiceServer interface {
	mustEmbedUnimplementedAIServiceServer()
}

func RegisterAIServiceServer(s grpc.ServiceRegistrar, srv AIServiceServer) {
	// If the following call pancis, it indicates UnimplementedAIServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AIService_ServiceDesc, srv)
}

func _AIService_ProcessAudioData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessAudioDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AIServiceServer).ProcessAudioData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AIService_ProcessAudioData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AIServiceServer).ProcessAudioData(ctx, req.(*ProcessAudioDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AIService_ProcessVideoFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessVideoFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AIServiceServer).ProcessVideoFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AIService_ProcessVideoFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AIServiceServer).ProcessVideoFrame(ctx, req.(*ProcessVideoFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AIService_StreamAudioProcessing_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AIServiceServer).StreamAudioProcessing(&grpc.GenericServerStream[AudioChunk, AIStreamResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AIService_StreamAudioProcessingServer = grpc.BidiStreamingServer[AudioChunk, AIStreamResult]

func _AIService_StreamVideoProcessing_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AIServiceServer).StreamVideoProcessing(&grpc.GenericServerStream[VideoChunk, AIStreamResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AIService_StreamVideoProcessingServer = grpc.BidiStreamingServer[VideoChunk, AIStreamResult]

func _AIService_GetAIAnalysis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAIAnalysisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AIServiceServer).GetAIAnalysis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AIService_GetAIAnalysis_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AIServiceServer).GetAIAnalysis(ctx, req.(*GetAIAnalysisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AIService_NotifyAIResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyAIResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AIServiceServer).NotifyAIResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AIService_NotifyAIResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AIServiceServer).NotifyAIResult(ctx, req.(*NotifyAIResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AIService_ServiceDesc is the grpc.ServiceDesc for AIService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AIService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.AIService",
	HandlerType: (*AIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProcessAudioData",
			Handler:    _AIService_ProcessAudioData_Handler,
		},
		{
			MethodName: "ProcessVideoFrame",
			Handler:    _AIService_ProcessVideoFrame_Handler,
		},
		{
			MethodName: "GetAIAnalysis",
			Handler:    _AIService_GetAIAnalysis_Handler,
		},
		{
			MethodName: "NotifyAIResult",
			Handler:    _AIService_NotifyAIResult_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAudioProcessing",
			Handler:       _AIService_StreamAudioProcessing_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamVideoProcessing",
			Handler:       _AIService_StreamVideoProcessing_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "services.proto",
}

const (
	NotificationService_SendNotification_FullMethodName       = "/grpc.NotificationService/SendNotification"
	NotificationService_SendBulkNotifications_FullMethodName  = "/grpc.NotificationService/SendBulkNotifications"
	NotificationService_GetNotificationHistory_FullMethodName = "/grpc.NotificationService/GetNotificationHistory"
)

// NotificationServiceClient is the client API for NotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 通知服务接口
type NotificationServiceClient interface {
	SendNotification(ctx context.Context, in *SendNotificationRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SendBulkNotifications(ctx context.Context, in *SendBulkNotificationsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	GetNotificationHistory(ctx context.Context, in *GetNotificationHistoryRequest, opts ...grpc.CallOption) (*GetNotificationHistoryResponse, error)
}

type notificationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationServiceClient(cc grpc.ClientConnInterface) NotificationServiceClient {
	return &notificationServiceClient{cc}
}

func (c *notificationServiceClient) SendNotification(ctx context.Context, in *SendNotificationRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, NotificationService_SendNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) SendBulkNotifications(ctx context.Context, in *SendBulkNotificationsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, NotificationService_SendBulkNotifications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) GetNotificationHistory(ctx context.Context, in *GetNotificationHistoryRequest, opts ...grpc.CallOption) (*GetNotificationHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNotificationHistoryResponse)
	err := c.cc.Invoke(ctx, NotificationService_GetNotificationHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServiceServer is the server API for NotificationService service.
// All implementations must embed UnimplementedNotificationServiceServer
// for forward compatibility.
//
// 通知服务接口
type NotificationServiceServer interface {
	SendNotification(context.Context, *SendNotificationRequest) (*empty.Empty, error)
	SendBulkNotifications(context.Context, *SendBulkNotificationsRequest) (*empty.Empty, error)
	GetNotificationHistory(context.Context, *GetNotificationHistoryRequest) (*GetNotificationHistoryResponse, error)
	mustEmbedUnimplementedNotificationServiceServer()
}

// UnimplementedNotificationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationServiceServer struct{}

func (UnimplementedNotificationServiceServer) SendNotification(context.Context, *SendNotificationRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendNotification not implemented")
}
func (UnimplementedNotificationServiceServer) SendBulkNotifications(context.Context, *SendBulkNotificationsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBulkNotifications not implemented")
}
func (UnimplementedNotificationServiceServer) GetNotificationHistory(context.Context, *GetNotificationHistoryRequest) (*GetNotificationHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationHistory not implemented")
}
func (UnimplementedNotificationServiceServer) mustEmbedUnimplementedNotificationServiceServer() {}
func (UnimplementedNotificationServiceServer) testEmbeddedByValue()                             {}

// UnsafeNotificationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServiceServer will
// result in compilation errors.
type UnsafeNotificationServiceServer interface {
	mustEmbedUnimplementedNotificationServiceServer()
}

func RegisterNotificationServiceServer(s grpc.ServiceRegistrar, srv NotificationServiceServer) {
	// If the following call pancis, it indicates UnimplementedNotificationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NotificationService_ServiceDesc, srv)
}

func _NotificationService_SendNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).SendNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_SendNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).SendNotification(ctx, req.(*SendNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_SendBulkNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBulkNotificationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).SendBulkNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_SendBulkNotifications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).SendBulkNotifications(ctx, req.(*SendBulkNotificationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_GetNotificationHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).GetNotificationHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_GetNotificationHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).GetNotificationHistory(ctx, req.(*GetNotificationHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NotificationService_ServiceDesc is the grpc.ServiceDesc for NotificationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.NotificationService",
	HandlerType: (*NotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendNotification",
			Handler:    _NotificationService_SendNotification_Handler,
		},
		{
			MethodName: "SendBulkNotifications",
			Handler:    _NotificationService_SendBulkNotifications_Handler,
		},
		{
			MethodName: "GetNotificationHistory",
			Handler:    _NotificationService_GetNotificationHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}
